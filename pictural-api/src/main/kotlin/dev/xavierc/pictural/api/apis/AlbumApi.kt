/**
 * Pictural API
 * This API is part of my project for the Shopify Developer intern challenge. This API manage the users, pictures and links between accounts of Pictural.
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: chretienxavier42@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package dev.xavierc.pictural.api.apis

import io.ktor.application.call
import io.ktor.http.HttpStatusCode
import io.ktor.response.respond

import dev.xavierc.pictural.api.Paths
import dev.xavierc.pictural.api.models.*
import dev.xavierc.pictural.api.repository.AlbumRepository
import io.ktor.locations.*
import io.ktor.request.*
import io.ktor.routing.*
import io.ktor.sessions.*
import org.kodein.di.instance
import org.kodein.di.ktor.di

@KtorExperimentalLocationsAPI
fun Route.AlbumApi() {
    val albumRepository by di().instance<AlbumRepository>()

    // Add an album
    post { _: Paths.AlbumAdd ->
                call.response.headers.append("Access-Control-Allow-Origin", "http://localhost:56928")
        call.response.headers.append("Access-Control-Allow-Credentials", "true")
        val user = call.sessions.get<UserSession>()

        if (user == null) {
            call.respond(HttpStatusCode.Unauthorized)
        } else {
            val req = call.receive<AlbumAddRequest>()

            val albumUuid = albumRepository.addAlbum(user.uid, req.title, req.images, req.friends)

            if(albumUuid != null) {
                call.respond(HttpStatusCode.Created, albumUuid)
            } else {
                call.respond(HttpStatusCode.InternalServerError)
            }
        }
    }

    // Edit an album
    put { request: Paths.AlbumUpdate ->
        val user = call.sessions.get<UserSession>()
                call.response.headers.append("Access-Control-Allow-Origin", "http://localhost:56928")
        call.response.headers.append("Access-Control-Allow-Credentials", "true")

        if (user == null) {
            call.respond(HttpStatusCode.Unauthorized)
        } else {
            // Get the album
            val album = albumRepository.getAlbum(request.albumUuid)

            when {
                album == null ->  call.respond(HttpStatusCode.NotFound)
                // Check if the current user can edit the album
                album.ownerUuid != user.uid && !album.friends.any { it.uuid == user.uid } -> call.respond(HttpStatusCode.Unauthorized)
                else -> {
                    val body = call.receive<AlbumUpdateRequest>()
                    val isSuccessful = albumRepository.updateAlbum(album.uuid, body.title)

                    if(isSuccessful) {
                        call.respond(HttpStatusCode.OK)
                    } else {
                        call.respond(HttpStatusCode.InternalServerError)
                    }
                }
            }
        }
    }

    // Delete an album
    delete { request: Paths.AlbumDelete ->
        val user = call.sessions.get<UserSession>()
                call.response.headers.append("Access-Control-Allow-Origin", "http://localhost:56928")
        call.response.headers.append("Access-Control-Allow-Credentials", "true")

        if (user == null) {
            call.respond(HttpStatusCode.Unauthorized)
        } else {
            // Get the album
            val album = albumRepository.getAlbum(request.albumUuid)

            when {
                album == null ->  call.respond(HttpStatusCode.NotFound)
                // Check if the current user can edit the album
                canEdit(album, user.uid) -> call.respond(HttpStatusCode.Unauthorized)
                else -> {
                    val isSuccessful = albumRepository.deleteAlbum(album.uuid)

                    if(isSuccessful) {
                        call.respond(HttpStatusCode.OK)
                    } else {
                        call.respond(HttpStatusCode.InternalServerError)
                    }
                }
            }
        }
    }

    // Get albums for the user logged
    get { _: Paths.AlbumsGet ->
        val user = call.sessions.get<UserSession>()
                call.response.headers.append("Access-Control-Allow-Origin", "http://localhost:56928")
        call.response.headers.append("Access-Control-Allow-Credentials", "true")

        if (user == null) {
            call.respond(HttpStatusCode.Unauthorized)
        } else {
            val albums = albumRepository.getAlbums(user.uid)

            call.respond(HttpStatusCode.OK, AlbumsListResponse(albums))
        }
    }

    // Add friends access to the album
    post { request: Paths.AlbumAccessAdd ->
        val user = call.sessions.get<UserSession>()
                call.response.headers.append("Access-Control-Allow-Origin", "http://localhost:56928")
        call.response.headers.append("Access-Control-Allow-Credentials", "true")

        if (user == null) {
            call.respond(HttpStatusCode.Unauthorized)
        } else {
            // Get the album
            val album = albumRepository.getAlbum(request.albumUuid)

            when {
                album == null ->  call.respond(HttpStatusCode.NotFound)
                // Check if the current user can edit the album
                canEdit(album, user.uid) -> call.respond(HttpStatusCode.Unauthorized)
                else -> {
                    val body = call.receive<AlbumAccessAddRequest>()
                    val isSuccessful = albumRepository.shareWith(album.uuid, body.friends)

                    if(isSuccessful) {
                        call.respond(HttpStatusCode.OK)
                    } else {
                        call.respond(HttpStatusCode.InternalServerError)
                    }
                }
            }
        }
    }

    // Remove friend access to the album
    delete { request: Paths.AlbumAccessDelete ->
        val user = call.sessions.get<UserSession>()
                call.response.headers.append("Access-Control-Allow-Origin", "http://localhost:56928")
        call.response.headers.append("Access-Control-Allow-Credentials", "true")

        if (user == null) {
            call.respond(HttpStatusCode.Unauthorized)
        } else {
            // Get the album
            val album = albumRepository.getAlbum(request.albumUuid)

            when {
                album == null ->  call.respond(HttpStatusCode.NotFound)
                // Check if the current user can edit the album
                album.ownerUuid != user.uid && !album.friends.any { it.uuid == user.uid } -> call.respond(HttpStatusCode.Unauthorized)
                else -> {
                    val isSuccessful = albumRepository.removeAccessTo(album.uuid, request.friendUuid)

                    if(isSuccessful) {
                        call.respond(HttpStatusCode.OK)
                    } else {
                        call.respond(HttpStatusCode.InternalServerError)
                    }
                }
            }
        }
    }

    // Add images into the album
    post { request: Paths.AlbumImageAdd ->
        val user = call.sessions.get<UserSession>()
                call.response.headers.append("Access-Control-Allow-Origin", "http://localhost:56928")
        call.response.headers.append("Access-Control-Allow-Credentials", "true")

        if (user == null) {
            call.respond(HttpStatusCode.Unauthorized)
        } else {
            // Get the album
            val album = albumRepository.getAlbum(request.albumUuid)

            when {
                album == null ->  call.respond(HttpStatusCode.NotFound)
                // Check if the current user can edit the album
                canEdit(album, user.uid) -> call.respond(HttpStatusCode.Unauthorized)
                else -> {
                    val body = call.receive<AlbumImageAddRequest>()
                    val isSuccessful = albumRepository.addImages(album.uuid, body.images)

                    if(isSuccessful) {
                        call.respond(HttpStatusCode.OK)
                    } else {
                        call.respond(HttpStatusCode.InternalServerError)
                    }
                }
            }
        }
    }

    // Delete an image from the album
    delete { request: Paths.AlbumImageDelete ->
        val user = call.sessions.get<UserSession>()
                call.response.headers.append("Access-Control-Allow-Origin", "http://localhost:56928")
        call.response.headers.append("Access-Control-Allow-Credentials", "true")

        if (user == null) {
            call.respond(HttpStatusCode.Unauthorized)
        } else {
            // Get the album
            val album = albumRepository.getAlbum(request.albumUuid)

            when {
                album == null ->  call.respond(HttpStatusCode.NotFound)
                // Check if the current user can edit the album
                canEdit(album, user.uid) -> call.respond(HttpStatusCode.Unauthorized)
                else -> {
                    val isSuccessful = albumRepository.removeImage(album.uuid, request.imageUuid)

                    if(isSuccessful) {
                        call.respond(HttpStatusCode.OK)
                    } else {
                        call.respond(HttpStatusCode.InternalServerError)
                    }
                }
            }
        }
    }
}

/**
 * Check if [album] is editable by [userUuid]
 */
fun canEdit(album: Album, userUuid: String): Boolean {
    return album.ownerUuid != userUuid && !album.friends.any { it.uuid == userUuid }
}
